<html>
<head>
<title>The JavaScript Encyclopedia: E</title>
<link rel="stylesheet" href="encyclopedia.css" type="text/css">
</head>

<body><h1>E</h1>
<h2 id="e">e</h2>
<p>The letter <code>e</code> or <code>E</code> can indicate the exponent part of a <a href="N.html#number literal">number literal</a>.</p>
<h3 id="E Math member"><code>E</code> <code>Math</code> number <dfn>e</dfn></h3>
<p><code>Math.E</code> contains an approximate value of <em>e</em> which is somewhere around    2.718281828459045. It is called Euler's number, and is the base of the natural logarithm. </p>
<p>It can be computed with an <a href="I.html#immediate function">immediate function</a>:</p>
<pre>Math.E = (function () {
    var e = 2,
        f = 1,
        i;
    for (i = 2; i < 18; i += 1) {
        f /= i;
        e += f;
    }
    return e;
}());</pre>
<p>Also see <a href="#exp Math function"><code>exp</code> <code>Math</code> function</a> <dfn>exponential</dfn> and <a href="log Math function"><code>log</code> <code>Math</code> function <dfn>natural logarithm</dfn></a>.</p>
<h2 id="E4X">E4X</h2>
<p>The ECMAScript for XML (E4X) Specification [<a href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-357.pdf">ECMA-357 Second Edition / December 2005</a>] is a standard that extends ECMAScript with XML literals and <a href="http://www.w3.org/TR/xpath">XPath</a>-like operators. It is not a part of <a href="E.html#ES3">ES3</a> or <a href="E.html#ES5">ES5</a>. It is not implemented in most  systems. The E4X extentions should be avoided because of their  lack of general availability and acceptance.</p>
<h2 id="Ecma">Ecma International</h2>
<p>Ecma International (fna European Computer Manufacturers Association) is the standards body that is responsible for the ECMAScript Programming Language Standard. It was founded in 1961 and is based in Geneva. See <a href="http://www.ecma-international.org/">http://www.ecma-international.org/</a>.</p>
<h2>ECMAScript</h2>
<p>Blah.</p>
<h2 id="ecursion">ecursion</h2>
<p>Blah.</p>

<h2>else <a href="R.html#reserved word"><strong>reserved word</strong></a></h2>
<p>See <a href="A.html#if statement"><code>if</code> statement</a>.</p>
<h2>empty statement</h2>
<p>The empty statement is a <a href="S.html#statement">statement</a> consisting of nothing but a <a href="special.html#;"><code>;</code> <dfn>semicolon</dfn></a>. It does not do anything. Its principle use is to mask syntax errors. The empty statement should be avoided.</p>

<h2 id="encodeURI">encodeURI</h2>
<h3 id="encodeURI global function"><code>encodeURI</code> global function</h3>
<p>Blah.</p>

<h2 id="encodeURIComponent">encodeURIComponent</h2>
<h3 id="encodeURIComponent global function"><code>encodeURIComponent</code> global function</h3>
<p>Blah.</p>
<h2 id="entity">entity</h2>
<p>An entity in <a href="H.html#HTML">HTML</a> is a character sequence that represents a single character. It is <a href="H.html#HTML">HTML</a>'s alternative to escapement as used in a <a href="S.html#string literal">string literal</a>. An entity begins with <a href="special.html#ampersand"><code>&amp;</code> <dfn>ampersand</dfn></a> and ends with <a href="special.html#;"><code>;</code> <dfn>semicolon</dfn></a>, and between them there may be a cryptic word or a number. This language tolerates <a href="H.html#HTML">HTML</a> entities in strings, but has no knowledge of them. </p>
<pre>'&amp;amp;'.length    // 5</pre>

<h2>enum <a href="R.html#reserved word"><strong>reserved word</strong></a></h2>

<h2 id="enumeration">enumeration </h2>
<p>See <a href="F.html#for in statement"><code>for</code> <code>in</code> statement</a>.</p>
<h3 id="enumeration function">enumeration function</h3>
<p>Blah.</p>
<h3>enumeration object</h3>
<p>An enumeration object is an <a href="O.html#object">object</a> that is used to map names or mnemonics to codes in the form of numbers or other values. Programs often make use of codes or constant values, but it is generally bad to scatter them thoughout a program because that can make the program difficult to read and modify. So instead we can collect the codes and constants into an object, giving descriptive keys to each one. The descriptive keys help make the program self documenting, and gives us a single place to change in the program should they need to be changed. </p>
<p>In some languages, there is an <code>enum</code> statement or operator that provides such mapping. In this language, simply use an <a href="O.html#object">object</a>.</p>
<pre>var score_poker_hand = (function () {

// This program creates and uses two enumeration objects:
// rank_value and score_prefix.

// The score_poker_hand function takes a hand (an array of cards). The hand
// can contain between 5 and 9 cards, within which it will find the best five
// card poker hand. A hand is an array of objects containing rank and suit
// properties. The order of the cards is not significant. The hand is not
// modified.

// It returns a string which is the hand's score. The score of a better hand
// will always be greater than the score of a lesser hand.

// We are wrapping the score_poker_hand function in an immediate function to
// hide its static data structures (rank_value, score_prefix) and functions
// (hex, count_cards, count_ranks, straight, of_a_kind, kicker).

// The traditional ranks do not sort correctly because 'Q' &gt; 'A', so we replace
// them with numbers in order to assure proper sequencing.  This also allows us
// to accept '10' or 'T' or 'Ten' or 'ten' as synonyms. Card ranks will be
// replaced according to the rank_value enumeration object. Later we will
// represent the ranks in base 16 so that they can be represented as single
// characters, so 'Ace' becomes 14 or 'e', and 'Ten' becomes 10 or 'a'.

    var rank_value = {
        '2':     2,   'Five':  5,   'eight': 8,    'J':     11,   'K':    13,
        'Two':   2,   'five':  5,   '9':     9,    'j':     11,   'k':    13,
        'two':   2,   '6':     6,   'Nine':  9,    'Jack':  11,   'King': 13,
        '3':     3,   'Six':   6,   'nine':  9,    'jack':  11,   'king': 13,
        'Three': 3,   'six':   6,   '10':    10,   '12':    12,   '14':   14,
        'three': 3,   '7':     7,   'T':     10,   'Q':     12,   '1':    14,
        '4':     4,   'Seven': 7,   't':     10,   'q':     12,   'A':    14,
        'Four':  4,   'seven': 7,   'Ten':   10,   'Queen': 12,   'a':    14,
        'four':  4,   '8':     8,   'ten':   10,   'queen': 12,   'Ace':  14,
        '5':     5,   'Eight': 8,   '11':    11,   '13':    13,   'ace':  14
    };

// The first character of the score indicates what kind of hand it is. The
// score_prefix is an enumeration object that maps the names of the poker
// hands to a single letter codes. The single letters sort correctly, so
//           score_prefix.straight_flush &gt; score_prefix.no_pair

    var score_prefix = {
        straight_flush:  'S',    // + high-card
        four_of_a_kind:  'K',    // + 4-rank + kicker
        full_house:      'H',    // + 3-rank + 2-rank
        flush:           'F',    // + 5 kickers
        straight:        'A',    // + high-card
        three_of_a_kind: '3',    // + 3-rank + 2 kickers
        two_pair:        '2',    // + 2-rank + 2-rank + kicker
        one_pair:        '1',    // + 2-rank + 3 kickers
        no_pair:         '0'     // + 5 kickers
    };

// The final score will contain a score_prefix and additional characters
// to help break ties. Examples:

// The worst poker hand from 5 cards is
//    no_pair + 7 5 4 3 2                     = '075432'

// The worst poker hand from 7 cards is
//      no_pair + 9 8 7 5 4                   = '098754'

// The best pair is
       one_pair + A A K Q J                   = '1eedcb'

// The best two pair is
//     two_pair + A A K K Q                   = '2eeddc'

// The best three of a kind is
//     three_of_a_kind + A A A K Q            = '3eeedc'

// The worst straight is
//     straight + 5 4 3 2 A                   = 'A5'

// The best flush that is not a straight flush is
//      flush + A K Q J 9                     = 'Fedcb9'

// The best full house is
//      full_house + A A A K K                = 'Heeedd'

// The best four of a kind is
//      four_of_a_kind + A A A A K            = 'Ked'

// The best poker hand is
//      straight_flush + A (Royal flush)      = 'Se'


    function hex(number) {

// Return the number as a base 16 string. We convert the codes for ten, jack,
// queen, king, and ace to 'a', 'b', 'c', 'd', and 'e'.

        return number.toString(16);
    }


    function count_cards(hand, select) {

// The count_cards function produces an object that contains the counts of the
// elements of an array. If there is no select parameter, then the truthy
// elements are counted. If the select parameter is a function, then the
// elements are each passed to the select function and the results are counted.
// Otherwise, if select is a string and the elements are objects, use the
// select string as a property name and count the properties.

// The result is an object where the keys are elements and the values are the
// counts for each element.

        var element, i, result = {};
        for (i = 0; i &lt; hand.length; i += 1) {
            element = hand[i];
            if (typeof select === 'function') {
                element = select(element);
            } else if (typeof select === 'string') {
                if (!element || typeof element !== 'object') {
                    throw new Error('count_cards expected an object');
                }
                element = element[select];
            }
            if (element) {

// If the current count for the element is not a number (most likely undefined,
// possibly an inherited method) then assign 1 to it. Otherwise, increment it.

                if (typeof result[element] !== 'number') {
                    result[element] = 1;
                } else {
                    result[element] += 1;
                }
            }
        }
        return result;
    }


    function count_ranks(hand) {
        return count_cards(hand, function (element) {
            return rank_value[element.rank];
        });
    }


    function straight(count) {

// Given a rank count, determine if it has a straight. Using the rank_value
// enumeraton object, starting with Ace and work down, look for 5 cards in a
// row. If they are found, return the value of the high card. The lowest
// straight has 6 high.

        var high, j, found;
        for (high = rank_value.ace; high &gt;= rank_value.six; high -= 1) {
            if (count[high]) {
                found = true;
                for (j = 1; j &lt; 5; j += 1) {
                    if (!count[(high - j)]) {
                        found = false;
                        break;
                    }
                }
                if (found) {
                    return high;
                }
            }
        }

// If holding an Ace, look for a wheel (5-4-3-2-A).

        if (count[rank_value.ace]) {
            for (j = rank_value.five; j &gt;= rank_value.two; j -= 1) {
                if (!count[j]) {
                    return false;
                }
            }
            return rank_value.Five;
        }
        return false;
    }


    function of_a_kind(count, number) {

// Given a rank count, find the highest rank that meets or exceeds the number.
// If successful, subtract the number and return the value. For example, if
// the count contains 4 aces, then of_a_kind(count, 4) would return 14 (the ace
// value) and reduce the ace count to zero. It looks first at the aces, then
// kings, and so on, looking finally at the twos.

        var value;
        for (value = rank_value.ace; value &gt;= rank_value.two; value -= 1) {
            if (count[value] &gt;= number) {
                count[value] -= number;
                return value;
            }
        }
        return false;
    }


    function kicker(count, number) {

// Produce a string containing the hex values of the count's highest ranking
// cards. The number parameter determines how many kickers to take.

        var result = '',
            value;
        for (value = rank_value.ace; value &gt;= rank_value.two; value -= 1) {
            while (count[value]) {
                result += hex(value);
                count[value] -= 1;
                number -= 1;
                if (number &lt;= 0) {
                    break;
                }
            }
        }
        return result;
    }


    return function score_poker_hand(hand) {

// This is the actual score_poker_hand function. It takes a hand of 5 to 9
// cards. If the hand is shorter than 5, then some hands will be impossible
// to produce. For example, with two cards, the only possible scores are
// one_pair and no_pair. If the hand is bigger than 9 cards, then it might
// produce an incorrect score in the case where the hand contains two or more
// flushes. Most games use 5 or 7 cards. The hand is not modified. A hand is
// an array of card objects. A card object has two properties, a rank and a
// suit. So
//      score_poker_hand([
//          {"rank": "four", "suit": "D"},
//          {"rank": "5",    "suit": "D"},
//          {"rank": "Ace",  "suit": "D"},
//          {"rank": "2",    "suit": "D"},
//          {"rank": "Q",    "suit": "D"}
//      ])    // 'Fec542'  (flush + AQ542)

        var count, flush, flush_count, high, pair, suit, suit_count;

// First look for a flush. Did we count 5 or more cards of the same suit?

        suit_count = count_cards(hand, 'suit');
        for (suit in suit_count) {
            if (typeof suit_count[suit] === 'number' &amp;&amp; suit_count[suit] &gt;= 5) {
                flush = suit;
                break;
            }
        }

// We see a flush. Is it a straight flush? To find out, make a flush hand
// that includes only the cards that are suited and test it for straightness.

        if (flush) {
            flush_count = count_ranks(hand.filter(function (element) {
                return element.suit === flush;
            }));
            high = straight(flush_count);
            if (high) {
                return score_prefix.straight_flush + hex(high);
            }
        }

// If it is not a straight flush, then make a new rank count that will be used
// for all of the following tests.

        count = count_ranks(hand);

// Four of a kind?

        high = of_a_kind(count, 4);
        if (high) {
            return score_prefix.four_of_a_kind + hex(high) + kicker(count, 1);
        }

// Full house? First look for a 3 of a kind. If we find one, look for a
// two of a kind. If we find one, then we have a full house. If we don't
// find the pair, then we have to undo the matching of the 3 of a kind
// so that it doesn't interfere with the matching of a straight.

        high = of_a_kind(count, 3);
        if (high) {
            pair = of_a_kind(count, 2);
            if (pair) {
                return score_prefix.full_house + hex(high) + hex(pair);
            }
            count[high] += 3;  // undo the matching of the 3 of a kind
        }

// Flush?

        if (flush) {
            return score_prefix.flush + kicker(flush_count, 5);
        }

// Straight?

        high = straight(count);
        if (high) {
            return score_prefix.straight + hex(high);
        }

// Three of a kind?

        high = of_a_kind(count, 3);
        if (high) {
            return score_prefix.three_of_a_kind + hex(high) + kicker(count, 2);
        }

// One pair? Two pair?

        high = of_a_kind(count, 2);
        if (high) {
            pair = of_a_kind(count, 2);
            if (pair) {
                return score_prefix.two_pair + hex(high) + hex(pair) +
                        kicker(count, 1);
            } else {
                return score_prefix.one_pair + hex(high) + kicker(count, 3);
            }
        }

// If all tests failed, then we have a no pair.

        return score_prefix.no_pair + kicker(count, 5);
    };
}());</pre>
<h2>epsilon</h2>
<p>Epsilon is the smallest positive number that can be added to 1 giving a result that is larger than 1. Positive numbers that are smaller than epsilon will underflow when added to 1. The value for epsilon is approximately 2.220446049250313e-16. It can be computed with this <a href="I.html#immediate function">immediate function</a>:</p>
<pre>var epsilon = (function () {
    var next, result;
    for (next = 1; 1 + next !== 1; next = next / 2) {
        result = next;
    }
    return result;
}());</pre>
<p>Epsilon is a measure of the limits of the accuracy of <a href="N.html#number">number</a>.</p>
<pre>1 + epsilon    // 1.0000000000000002 (approximately)
2 + epsilon    // 2 (exactly)  </pre>
<h2 id="error">error</h2>
<h3 id="Error global function"><code>Error</code> global function</h3>
<p>Blah.</p>

<h2 id="ES3">ES3</h2>
<p class=es3>ECMAScript Programming Language Standard, Third Edition [1999].</p>

<h2 id="ES5">ES5</h2>
<p>ECMAScript Programming Language Standard, Fifth Edition [2009].</p>
<h2 id="eteration">eteration</h2>
<p>Blah.</p>

<h2 id="eval">eval</h2>
<h3 id="eval global function"><code>eval</code> global function</h3>
<p>Blah.</p>

<h2 id="EvalError">EvalError</h2>
<h3 id="EvalError global function"><code>EvalError</code> global function</h3>
<p>Blah.</p>
<h2>event loop</h2>
<p>Blah.</p>

<h2 id="every">every</h2>
<h3 id="every Array prototype function"><code>every</code> array prototype function</h3>
<p>Blah.</p>

<h2 id="exceptions">exceptions</h2>
<p>Blah.</p>

<h2 id="exec">exec</h2>
<h3 id="exec Rexexp prototype function"><code>exec</code> <code>RexExp</code> prototype function</h3>
<p>Blah.</p>

<h2 id="exp">exp</h2>
<h3 id="exp Math function"><code>exp</code> <code>Math</code> function <dfn>exponential</dfn></h3>
<p>The <code>Math.exp(</code><var>number</var><code>)</code> function returns <a href="#E Math number"><var>e</var></a> raised to the <var>number</var> power. This is an approximate implementation: </p>
<pre>Math.exp = function exp(number) {
    number = +number;
    var fac = 1,
        i,
        result = 1 + number,
        xx = number;
    for (i = 2; i < 20; i += 1) {
        xx *= number;
        fac *= i;
        result += xx / fac;
    }
    return result;
};</pre>
<p>Also see <a href="#E Math number"><code>E</code> <code>Math</code> number <dfn>e</dfn></a>.</p>
<h2>exponentiation</h2>
<p>See <a href="P.html#pow Math function"><code>pow</code> <code>Math</code> function <dfn>raise to a power</dfn></a>.<br>
</p>
<h2>expression</h2>
<p>An expression is a sequence of tokens that delivers a value. An expression can be one of:</p>
<ul>
  <li><a href="C.html#constant">constant</a></li>
  <li><a href="L.html#literal">literal</a></li>
  <li><a href="F.html#function">function</a></li>
  <li><a href="V.html#variable">variable</a></li>
  <li><a href="P.html#parameter">parameter</a></li>
  <li><code>(</code>&nbsp;&nbsp;&nbsp;<a href="#expression">expression</a>&nbsp;&nbsp;&nbsp;<code>)</code>&nbsp;&nbsp;&nbsp;&nbsp;<dfn>an operand wrapped in grouping parentheses</dfn></li>
  <li><a href="P.html#prefix operator">prefix operator</a>&nbsp;&nbsp;&nbsp;<a href="#expression">expression</a><a href="#operand"></a></li>
  <li><a href="#expression">expression</a><a href="#operand"></a>&nbsp;&nbsp;&nbsp;<a href="S.html#suffix operator">suffix operator</a></li>
  <li><a href="#expression">expression</a><a href="#operand"></a>&nbsp;&nbsp;&nbsp;<a href="I.html#infix operator">infix operator</a>&nbsp;&nbsp;&nbsp;<a href="#expression">expression</a><a href="#operand"></a></li>
  <li><a href="#expression">expression</a><a href="#operand"></a>&nbsp;&nbsp;&nbsp;<code>?</code>&nbsp;&nbsp;&nbsp;<a href="#expression">expression</a><a href="#operand"></a>&nbsp;&nbsp;&nbsp;<code>:</code>&nbsp;&nbsp;&nbsp;<a href="#expression">expression</a><a href="#operand"></a>&nbsp;&nbsp;&nbsp;&nbsp;<dfn> ternary operator</dfn></li>
  <li><a href="#expression">expression</a><a href="#operand"></a>&nbsp;&nbsp;&nbsp;<a href="A.html#assignment infix operator">assignment infix operator</a>&nbsp;&nbsp;&nbsp;<a href="#expression">expression</a><a href="#operand"></a></li>
</ul>
<p>A compound expression can be formed by combining one or more expressions with an operator. Expressions can be nested inside of other expressions. The whole expression produces a single value. The order in which the operators are evaluated depends on <a href="G.html#grouping parentheses">grouping parentheses</a> and <a href="#operator precedence">operator precedence</a>. </p>
<p>When an expression provides a value to an <a href="O.html#operator">operator</a>, it is called an <a href="O.html#operand">operand</a>.</p>
<p>When an expression provides a value to a <a href="F.html#function">function</a>, it is called an <a href="A.html#argument">argument</a>.</p>
<p>When an expression occurs on the left side of an  <a href="A.html#assignment infix operator">assignment infix operator</a>, it is called an <a href="L.html#lvalue">lvalue</a>. When an expression occurs on the right side of an <a href="A.html#assignment infix operator">assignment infix operator</a>, it is called a value, specifically it is the value to be stored in the <a href="L.html#lvalue">lvalue</a>.</p>
<p>An expression can produce a value that can control a <a href="S.html#statement">statement</a>:</p>
<ul>
  <li><a href="D.html#do statement"><code>do</code> statement</a></li>
  <li><a href="F.html#for statement"><code>for</code> statement</a></li>
  <li><a href="I.html#if statement"><code>if</code> statement</a></li>
  <li><a href="S.html#switch statement"><code>switch</code> statement</a></li>
  <li><a href="W.html#while statement"><code>while</code> statement</a></li>
</ul>
<h3 id="operand statement">expression statement</h3>
<p>An expression can be used as a <a href="H.html#HTML">statement</a>. Generally, the only expressions that make sense as statements are assignment and invocations. The other forms of expressions are allowed, but most are useless, or even dangerous in that  errors can be masked.</p>
<p>An expression statement should end with a <a href="special.html#;"><code>;</code></a> <dfn>semicolon</dfn>.</p>
<pre>alert('When my friends need some code who do they call?');
force = mass * velocity;
i += 1;    // add 1 and i and store the result in i
i + 1;     // add 1 and i and ignore the result
i;         // get the value of i and ignore it</pre>
<h2>export <a href="R.html#reserved word"><strong>reserved word</strong></a></h2>

<h2>extends <a href="R.html#reserved word"><strong>reserved word</strong></a></h2>
</body>
</html>
